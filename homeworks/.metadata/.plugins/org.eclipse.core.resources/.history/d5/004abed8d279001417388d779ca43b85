package homework5;


import umontreal.iro.lecuyer.randvar.*;
import umontreal.iro.lecuyer.rng.MRG32k3a;
import umontreal.iro.lecuyer.rng.RandomStream;
import umontreal.iro.lecuyer.stat.Tally;
import umontreal.iro.lecuyer.stat.TallyStore;
import umontreal.iro.lecuyer.probdist.*;

public class ex4 {




	
	public void arrayCopy(double[] source, double[] destination)
	{
		assert(source.length==destination.length);
		for(int i = 0; i < source.length; i++)
			destination[i] = source[i];
	}
	
	private double simulateCV(int numRuns, int numPilotRuns, double barrier) {
		
		
		// we use without barrier as a CV
		double r = 0.08;     // short rate
		double sigma = 0.2;  // volatility
		double K = 100.;     // strike price
		double s_0 = 100.;   // initial price
		double T = 1;        // total time difference
		int s=10;            // number of evenly spaced observations
		int runSize = 10000; // size of each simulation
		EuropeanCallOption option = new EuropeanCallOption(r, sigma, K, s_0, T, s);
		
		TallyStore stats = new TallyStore();
		
		long[] seed = new long[]{ 1, 12345, 12345, 12345, 12345, 12345 };
		MRG32k3a prng = new MRG32k3a();
		prng.setSeed(seed);
		
		
		
		// PILOT RUNS
		
		
		
		// generate the baseline (without barrier)
		option.simulateRunsStd(runSize, prng, stats);
		double[] CV = new double[runSize];
		arrayCopy(stats.getArray(), CV);
		
		// generate the runs with the barriers
		double[] barriers = new double[]{80, 90, 95};
		double[] barrierResults = new double[barriers.length][];
		
		
		
		for(int i = 0; i < barriers.length; i++)
		{
			prng.resetStartStream();
			stats.init();
			option.simulateRunsBarrier(runSize, barriers[i], prng, stats);
			barrierResults[i] = new double[runSize];
			arrayCopy(barrierResults[i], stats.getArray());
		}
		
		
	
		
		// Pilot runs to estimate the variances and covariances for beta.
		for (int i = 0; i < numPilotRuns; i++)
			simulateOneDay(true, true);

		// calculate the pilot stats
		double meanApilot = statArrivals.average();
		double varApilot = statArrivals.variance();
		double meanXpilot = statGoodQoS.average();
		double varXpilot = statGoodQoS.variance();
		double covarAXpilot = statArrivals.covariance(statGoodQoS);
		double meanDpilot = meanApilot - meanXpilot;
		double varDpilot = varApilot + varXpilot - 2.0 * covarAXpilot;
		double covarADpilot = varApilot - covarAXpilot;
		

		println("\n\n==== PILOT RUN RESULTS ====");
		println("Mean(Arrivals) = " + f(meanApilot) + ",  Var(Arrivals) = " + f(varApilot));
		println("Covar(A,X) = " + f(covarAXpilot));
		println("Covar(A,D) = " + f(covarADpilot));
		println();


		// Perform crude simulations to estimate means and variances.
		this.statArrivals.init();
		this.statWaits.init();
		this.statGoodQoS.init();
		this.statAbandon.init();
		
		// Crude runs
		for (int i = 0; i < numRuns; i++)
			simulateOneDay(true, true);

		// Empirical means and variances.
		double meanA = statArrivals.average();
		double varA = statArrivals.variance();
		double meanX = statGoodQoS.average();
		double varX = statGoodQoS.variance();
		double varMC = varX; // Variance with crude MC.
		double covarAX = statArrivals.covariance(statGoodQoS);
		double meanD = meanA - meanX;
		double varD = varA + varX - 2.0 * covarAX;
		// Note: cov(A,A-X) = var(A) - cov(A,X).
		double covarAD = varA - covarAX;
		double betaVC; // Coefficient for VC.

		DoubleArrayList A = statArrivals.getDoubleArrayList();
		DoubleArrayList X = statGoodQoS.getDoubleArrayList();
		
		// get the indirect estimator
		TallyStore statBadService = new TallyStore(numRuns);
		for (int i = 0; i < numRuns; i++) {
			statBadService.add(A.get(i) - X.get(i));
		}
		DoubleArrayList D = statBadService.getDoubleArrayList();

		println("\n==== CRUDE ESTIMATOR RESULTS ====");
		println("meanA = " + f(meanA) + ",   Var(A) = " + f(varA));
		println("meanX = " + f(meanX) + ",   Var(X) = " + f(varX));
		println("meanD = " + f(meanD) + ",   Var(D) = " + f(varD));
		println("Covar(A,X) = " + f(covarAX));
		println("Covar(A,D) = " + f(covarAD));
		println();

		println("\n==== INDIRECT ESTIMATOR RESULTS ====");
		println("meanX = " + f(a - meanD) + ",   Var(D) = " + f(varD)
				+ ",   ratio = " + f(varD / varMC));
		println();
		
		A = statArrivals.getDoubleArrayList();
		X = statGoodQoS.getDoubleArrayList();
		D = statBadService.getDoubleArrayList();
		
}

	public static void reproduceResults()
	{
		// reproduce results Boyle, Broadie, and Glasserman, 1997
		double r = 0.1;
		double sigma = 0.2;
		double s_0 = 100;
		double K = 100;
		double T = 0.2;
		int s = 5;
		int n = 10000;
		double barrier = 0;
		EuropeanCallOption option = new EuropeanCallOption(r, sigma, K, s_0, T, s);
		Tally stats = new Tally();
		MRG32k3a prng = new MRG32k3a();
		option.simulateRunsBarrier(n, barrier, prng, stats);
		System.out.println(stats.report());
		System.out.println(option.getExpectedValue(s_0, K, r, sigma, T));
		
		
	}
	
	public static void main(String[] args) {
		// STATEMENT
		/*
		 * You are asked to try the control variate suggested in Example 6.18.
		 * Estimate the variance reduction factor compared with naive Monte
		 * Carlo by performing n = 10000 simulation runs with the following
		 * parameters: Ïƒ = 0.2, r = 0.08, S(0) = 100, T = 1, K = 100, d = 10,
		 * and t j = j/10 for j = 1, . . . , d. For the barrier , try = 80, 90,
		 * and 95. Discuss your results. Can you suggest other ways of reducing
		 * the variance for this example?
		 */

		/* the control variate suggested in example 6.18 is:
		 * to use the standard European option (i.e. with barrier = -Inf)
		 */
		
		//reproduceResults();
		
		
		TallyStore t = new TallyStore();
		for(int i = 0; i < 100; i++)
			t.add(i);
		double[] obs1 = t.getArray();
		
		t.init();
		for(int i = 0;i < 100; i++)
			t.add(2*i);
		
		double[] obs2 = t.getArray();
		
		for(int i = 0; i < obs1.length; i++)
			System.out.println(obs1[i]+ " " + obs2[i]);
		
		/*
		
		double[] barriers = new double[]{80, 90, 95};
		
		double r = 0.08;     // short rate
		double sigma = 0.2;  // volatility
		double K = 100.;     // strike price
		double s_0 = 100.;   // initial price
		double T = 1;        // total time difference
		int s=10;            // number of evenly spaced observations
		int runSize = 10000; // size of each simulation
		EuropeanCallOption option = new EuropeanCallOption(r, sigma, K, s_0, T, s);
		
		Tally stat = new Tally(); // will store the result values and be reinitialized each run
		
		long[] seed = new long[]{ 1, 12345, 12345, 12345, 12345, 12345 };
		MRG32k3a prng = new MRG32k3a();
		prng.setSeed(seed);
		
		
		
		// Make a run, just to check that the standard model
		// fits the expected Black-Scholes calculated value
		System.out.println("================Practice run================");
		stat.init();
		option.simulateRunsStd(runSize, prng, stat);
		System.out.println(stat.report());
		System.out.println("expected " + option.getExpectedValue(s_0, K, r, sigma, T));
		System.out.println("============================================\n");
		prng.resetStartSubstream();

		
		// Make a run with barrier = 80
		System.out.println("================barrier "+barriers[0] +" ================");
		stat.init();
		option.simulateRunsBarrier(runSize,barriers[0], prng, stat);
		System.out.println(stat.report());
		System.out.println("============================================\n");
		prng.resetStartSubstream();
		
		// Make a run with barrier = 90
		System.out.println("================barrier "+barriers[1] +" ================");
		stat.init();
		option.simulateRunsBarrier(runSize,barriers[1], prng, stat);
		System.out.println(stat.report());
		System.out.println("============================================\n");
		prng.resetStartSubstream();
		
		
		// Make a run with barrier = 95
		System.out.println("================barrier "+barriers[2] +" ================");
		stat.init();
		option.simulateRunsBarrier(runSize,barriers[2], prng, stat);
		System.out.println(stat.report());
		System.out.println("============================================\n");

		
		
		
		//System.out.println("Original settings\n");
		//simulate(0, 10000, prng, r, sigma, K, s_0, T);
		//prng.resetStartSubstream();
		
		/*
		simulate(Double.NEGATIVE_INFINITY, 10000, prng, r, sigma, K, s_0, T);
		prng.resetStartSubstream();
		
		/*
		simulate(90, 10000, prng);
		prng.resetStartSubstream();
		simulate(95, 10000, prng);
		prng.resetStartSubstream();
		
		System.out.println("With CV");
		*/
	}

	
}
